---
title: "Recommended Print List"
author: "Ken Brooks"
date: "November 13, 2015"
output: pdf_document
---

Prepare Environment
-------------------

```{r libraries, warning=FALSE, echo=FALSE, error=FALSE}
# clear environment and load libraries
rm(list = ls())

# note: use install_packages.Rmd for installation
library(xts)
library(readxl)
library(plyr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(lubridate)
library(forecast)
source("Inv_Planning.R")


```

Import data
-----------

```{r read, echo=FALSE}

filename <- "Sales by month v3.csv"

data = read.csv(filename)
```

Prepare data
------------
Data preparation involves two steps once the import from the csv file is complete:
* Making sure that nothing has changed in the formatting of the input data.  This is accomplished via the "checkData" function.
* Doing base cleanup on data to make sure that dates are formatted correctly, among other things. This is performed via the "cleanImportedData" function.

checkData(data) function
------------------------
The "checkData" function is used to verify that the format of an incoming CSV file has not changed from that expected.

Usage:
* The function takes a data frame, data, as an input. 
* It returns nothing, but if a change in format has occurred, it throws an error encouraging the analyst to discover what has changed in the input data structure.
* A future enhancement of this function would identify the specific location of the error. 

cleanImportedData(data) function
--------------------------------
The "cleanImportedData" function is used to perform base cleanup on imported data to make sure that dates are formatted correctly, among other things. 

Usage:
* The function takes a data frame, data, as an input. 
* It returns a data frame with correctly formatted columns for further processing.


```{r format.data}

checkData(data)  # check that nothing has changed in input format
data <- cleanImportedData(data)  # cleanup imported data
saveRDS(data, "data.rds")

```

Build data frames
-----------------
There are two data frames required for further analysis: the title.data data frame and the time.series.data data frame.  These two data frames hold title metadata and title historical demand, respectively and are created by the "createTitleDF(data)" and "createTSDF(data)" functions.

createTitleDF(data) function
----------------------------
The createTitleDF(data) function extracts title metadata from the imported file, normalizes the result and saves the data into a .rds file.

Usage:
* The function takes the imported and cleaned data frame from cleanImportedData(data)
* It returns a normalized title.data data frame and saves title_data.rds to disk.

createTSDF(data) function
----------------------------
The createTSDF(data) function extracts title demand data from the imported file, normalizes the result and saves the data into a .rds file. The TSDF in the function name refers to "Time Series Data Frame."

Usage:
* The function takes the imported and cleaned data frame from cleanImportedData(data).
* It returns a time.series.data data frame and saves time_series.rds to disk.

```{r data.frames}

# Retrieve stored data
data = readRDS("data.rds")

title.data <- createTitleDF(data)  # create title metadata df
time.series.data <- createTSDF(data)  # create time.series df


saveRDS(title.data, "title_data.rds")
saveRDS(time.series.data, "time_series.rds")

```


Forecast a single title
-----------------------
The "n.month.forecast" function is used to generate a forecast for a single title.   It generates a forecast over the specified horizon for a particular isbn.

Usage:
* The function takes an isbn as a string, a time series dataframe (to look up the data), and a specified horizon.  
* It returns a single column dataframe of the forecast, indexed by the date of the forecast.
* Examples:

```{r}

isbn = "0716756676"  # set the ISBN (this can be changed)

time.series.data = readRDS("time_series.rds") # read the time series data

fcst <- n.month.forecast(isbn, time.series.data, 15) # generate the forecast 

fcst  # display it

```

Forecast all titles
-------------------

The "build.forecast.DF" function is used to generate a forecast for all of the titles in a title.data data frame.   It uses "n.month.forecast" above, iteratively to generate the forecasts.

Usage:
* The function takes a title.data data frame and and time.series.data data frame (see above)  
* It returns a data frame of forecasts along with 3, 6, 9, 12 and 15-month accumulations. 
* It saves these to both to rds and CSV

Enhancements:
* Check the csv for strings in the ISBNs - dropping leading zeros
* Replace all negative forecasts with 0 before doing the sum (or do this on the base forecast?)

Examples:

```{r forecast, warning=FALSE, error=FALSE}

# Get all of the time series and title data
time.series.data = readRDS("time_series.rds")
title.data = readRDS("title_data.rds")

title.forecasts <- build.forecast.DF(title.data, time.series.data)

```

previous.edition.isbn(isbn, title.df)
-------------------------------------
This function returns the previous edition's ISBN.

Usage:
* Takes ISBN as a string, and a data frame as an input.
* It returns the previous ISBN as a string, or NA if no previous ISBN is available.

```{r previous.edition.isbn}

title.data = readRDS("title_data.rds")
source("Inv_Planning.R")

isbn1 = "1319056911"  # How Life Works
previous.edition.isbn(isbn1, title.data)

isbn2 <- "031243829X"  # Note that this title does not have a previous edition
previous.edition.isbn(isbn2, title.data)  # should fail

```

sum.edition.data(isbn, time.series.data, title.data)
----------------------------------------------------
In the event that a title does not have sufficient data to generate a forecast, it might be helpful to add the previous edition's data to the current edition to provide a longer time series.  This function essentially creates a third title by adding the current edition's data and the previous edition's data.

Usage:
* Takes an ISBN as a string and two data frames: title data and title time series as inputs
* Returns a new time series with the summed values from that ISBN and its previous edition. If there is no previous edition, it returns the data from the first edition only.

```{r sum.edition.data}

time.series.data = readRDS("time_series.rds")
title.data = readRDS("title_data.rds")
source("Inv_Planning.R")

isbn1 = "1319056911"  # How Life Works
sum.edition.data(isbn1, time.series.data, title.data)

isbn2 <- "031243829X"  # Note that this title does not have a previous edition
sum.edition.data(isbn2, time.series.data, title.data)  
# which should be the same as the data from the previous edition:
time.series.data[,isbn2]

```


align.previous.edition(isbn, time.series.data, title.data)
----------------------------------------------------------
The align.previous.edition() function takes an ISBN (as a string) and two data frames: title data and title time series as inputs and plots the time series and the previous edition aligned at peak sales.  It returns the previous title sales shifted in time so that the previous edition sales can be used as a forecast for the current edition. If there is no previous edition, it returns an NA.

```{r align.previous.edition}

time.series.data = readRDS("time_series.rds")
title.data = readRDS("title_data.rds")
source("Inv_Planning.R")

isbn1 = "1319056911"  # How Life Works
align.previous.edition(isbn1, time.series.data, title.data)

isbn3 <- "031243829X"  # Note that this title does not have a previous edition
align.previous.edition(isbn3, time.series.data, title.data)  # should fail

```

forecast.zeros(ts, horizon)
---------------------------
This function ttakes a time series and a horizon and returns a 0 forecast over that horizon.

```{r forecast.zeros}

time.series.data = readRDS("time_series.rds")
title.data = readRDS("title_data.rds")
source("Inv_Planning.R")

isbn1 = "1319056911"  # How Life Works
ts = time.series.data[,isbn1] # get the time series for this title
forecast.zeros(ts, 15)

# should this only be the point forecast?
```


output.multiple(isbn, time.series.data, title.data)
---------------------------------------------------
Generates multiple forecast variants based on the amount of information available for title demand.  Among the forecasts considered are:
* An n.month.forecast()
* A forecast based on sum.edition.data()
* Data from the previous edition shifted to be the forecast for the current edition from align.previous.edition()
* forecast.zeros() in the event that nothing works

Usage
* The function takes an ISBN (as a string) and time.series.data and title.data data frames
* The function returns a datafram of all relevant forecasts and saves a CSV file (isbn.csv), with the same information for inspection and usage


```{r output.multiple, warning=FALSE, error=FALSE}

rm(list = ls())
# Get all of the time series and title data
time.series.data = readRDS("time_series.rds")
title.data = readRDS("title_data.rds")
source("Inv_Planning.R")


isbn = "1319056911"  # How Life Works
output.multiple(isbn, time.series.data, title.data)

# isbn2 = "0312132921"
# output.multiple(isbn2)
# isbn3 <- "031243829X"
# output.multiple(isbn3)

```


Review Individual Titles
------------------------

```{r}

time.series = readRDS("time_series.rds")
title.data = readRDS("title_data.rds")

title.data$Isbn

isbn1 <- "0312132921"
isbn2 <- "031241501X" # skewed title 1
isbn3 <- "312566735" # skewed title 2
isbn4 <- "145760647X" # skewed title 3

skewed.isbns <- as.list(c(isbn2, isbn3, isbn4))
ts1 = time.series[, isbn4]
sum(!is.na(ts1))
ts1.fcst = forecast(ts1, h = 15)
plot(ts1.fcst)

# test actions.
str(ts1.fcst)
ts1.fcst$method
print(length(na.contiguous(ts1)))


```

Plot two time series on a single axis
-------------------------------------

```{r plot.two}

isbn1 <- "031241501X"
isbn2 <- "031243829X"
time.series = readRDS("time_series.rds")

plot.two <- function(isbn1, isbn2, ts) {
  # Plots two ISBNs in a facet plot, one over the other.  Takes 2 ISBNs as
  # strings and a time series data frome as input and generates two plots.
  plot.data <- ts[,c(isbn1, isbn2)]
  plot.data <- zoo::na.trim(plot.data, sides = "left", is.na = "all")
  plot(plot.data, main = "Comparative Time Series Plot", 
       xlab = "Date",
       ylab = "Units",
       plot.type = "s", 
       col = 1:2)
  legend("topright", 
         legend = c(isbn1, isbn2),
         lty = c(1,1),
         col = 1:2)
  }

plot.two(isbn1, isbn2, time.series)


```

Plot title and previous edition (if any)
----------------------------------------

```{r previous.edition}

time.series = readRDS("time_series.rds")
title.data = readRDS("title_data.rds")

isbn1 = "1319056911"  # How Life Works
isbn2 = "0312132921"
isbn3 <- "031243829X"

plot.previous.edition <- function(isbn, ts.data, title.data){
  # Takes an ISBN as a string and two data frames: title data and title
  # time series as inputs and plots the time series and
  # the previous edition.  If there is no previous edition, it returns 
  # an NA.
  
  isbn.prev <- previous.edition.isbn(isbn, title.data) # Get previous edition
  
  # Fail if there's no previous edition (isbn.prev == NA)
  if (is.na(isbn.prev)) {
    return(NA)
    }
  
  # Fail if previous edition has no data (not yet implemented)
  
  # Plot results
  plot.two(isbn1, isbn.prev, time.series)
}

# Test plot.previous.edition
plot.previous.edition(isbn1, time.series, title.data)
plot.previous.edition(isbn2, time.series, title.data)

isbn3 <- "031243829X"
plot.previous.edition(isbn3, time.series, title.data)

```




Test decomposition with STL

```{r}

isbn = "1319056911"  # How Life Works
isbn.fit = stl(isbn, s.window = "periodic")
plot(isbn.fit)

```

Transplant model from previous edition
--------------------------------------
* Add the previous edition to the current and forecast that
* Decompose the previous edition and use the seasonal factors to forecast the current edition, based on current trend

```{r test.transplant.forecast}

# Make current edition and previous edition start with the same year.

time.series = readRDS("time_series.rds")
title.data = readRDS("title_data.rds")

isbn = "1319056911"  # How Life Works
isbn2 = "0312132921"
isbn3 <- "031243829X"

forecast.with.previous <- function(isbn, ts.data, title.data){
  # Takes an ISBN as a string and two data frames: title data and title
  # time series as inputs and uses the model from the previous edition
  # to forecast the new edition. Returns an NA if there's no previous
  # edition.
  
  isbn.prev <- previous.edition.isbn(isbn, title.data) # Get previous edition
  
  # Fail if there's no previous edition (isbn.prev == NA)
  if (is.na(isbn.prev)) {
    return(NA)
    }
  # Fail if previous edition has no data (not yet implemented)
  ts1 = time.series[, isbn]
  ts1 <- zoo::na.trim(ts1, sides = "both", is.na = "all")
  print(ts1)
  ts1.fcst = forecast(ts1, h=15)
  plot(ts1.fcst)
  
  ts2 = time.series[, isbn.prev]
  ts2 <- zoo::na.trim(ts2, sides = "both", is.na = "all")
  print(ts2)
  ts2.fcst = forecast(ts2, h=15)
  plot(ts2.fcst)
  
  temp = merge.zoo(ts1, ts2)
  temp[is.na(temp)] <- 0
  ts3 = temp[,1] + temp[,2]
  ts3 = ts(ts3, start = start(ts3), frequency = 12)
  ts3[ts3 < 0] <- 0
  print(ts3)
  ts3.fcst = forecast(ts3, h=15)
  plot(ts3.fcst)

}

# Test plot.previous.edition
forecast.with.previous(isbn1, time.series, title.data)
# align.previous.edition(isbn2, time.series, title.data)

isbn3 <- "031243829X"
forecast.with.previous(isbn3, time.series, title.data)  # should fail

```

Recommend titles to examine
---------------------------

```{r}

title.data = readRDS("title_data.rds")
title.forecasts = readRDS("forecasts.rds")

# add another column for whether a review is required

calc.review <- function(forecast, onhand){
  if(forecast == 0){"Insuff data"}
  else if(forecast > onhand){"Print review"}
  else{"No Review"}
}

title.planning <- title.data %>% rowwise() %>% 
  dplyr::mutate(Review = calc.review(title.forecasts$three, (Available + Reserved.Stock + Sets.Made.Up))) %>% 
  dplyr::arrange(Review) %>% 
  mutate(OQ.6 = title.forecasts$six) %>% 
  mutate(OQ.9 = title.forecasts$nine) %>% 
  mutate(OQ.12 = title.forecasts$twelve) %>% 
  mutate(OQ.15 = title.forecasts$fifteen)

# output to csv

saveRDS(title.planning, "title_planning.rds")
write.csv(file="Title_Planning.csv", x=title.planning)

```

Release Notes
-------------
v6
* plot.two function
  * Eliminate leading blanks in plot.two function
  * Moved both lines into same panel for easier comparison
* align.previous edition
  * added function align.previous.edition to produce plot
  * it aligns peaks, not months - this may need to be changed
  * It probablly also needs an export, or to at least to print the prev isbn in the legend
v7
* skipped
v8
* sum.previous.edition function created
* output.multiple function created
